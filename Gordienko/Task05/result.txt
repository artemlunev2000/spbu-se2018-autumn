		5              10                  100          1K              10K          100K          1M          10M          100M
bubble		0	       0		    0	         0	        0.5          64           N/A          N/A          N/A
insertion	0	       0		    0	         0	        0.1         14.4          N/A	       N/A          N/A
merge		0	       0	 	    0 	         0 	         0          0.02          0.5           7	    N/A
quick		0 	       0		    0	         0	         0          0.03          0.5          5.4          100   
heap		0	       0		    0	         0 	         0          0.04          0.9          15.4	    262

В ходе эксперимента использовались случайно сгенерированные строки длиной 5 символов. Замер времени производился с помощью функции clock() стандартной библиотеки time.h.
Алгоритмы сложностью О(n*n) показывали хороший результат при относительно малых данных. Но при увеличении строк(>1k) их эффективность сначительно снизилась.
Алгоритмы сложностью О(n*logn) работали примерно одинаково до 1М, после чего heapSort начал уступать. Сортировка mergeSort на 10М оказалась медленнее quickSort на довольно существенное время, а на 100М ей и вовсе не хватило памяти.
Таким образом, в данных реализациях наиболее эффективным является quickSort.